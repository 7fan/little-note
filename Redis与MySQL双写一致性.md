# Redis与MySQL双写一致性

> 用了Redis，就别去追求强一致性

## 三种缓存模式
- Cache-Aside Pattern
- Read-Through/Write-Through
- Write-behind

### Cache-Aside Pattern
#### 读流程
先查缓存，缓存没有则读数据库，然后设置缓存

#### 写流程
先更新数据库，再删除缓存

### Read-Through/Write-Through
> 与Cache-Aside Pattern的区别：增加中间层，程序只与中间层沟通，中间层负责数据的读取和刷新
#### 读流程
程序请求中间层，中间层判断缓存是否有数据，没有数据则从数据库中读取，并写入缓存，再返回给程序

#### 写流程
程序请求中间层，中间层更新数据库，中间层删除缓存

### Write-behind
> 中间层将缓存作为对外的数据所有者，通过异步的方式将缓存刷入数据库
#### 写请求
程序请求中间层，中间层更新缓存，返回结果给程序；中间层异步更新数据库

---

## 一致性原因
### 为何是删缓存
- 一般的更新缓存相对删除缓存更耗时，线程并发导致数据不一致的概率更高
- 写多读少的场景，更新了并不一定会被读，浪费性能

### 为何会不一致
删缓存、写数据库，或写数据库、删缓存，都不是原子操作，不能保证线程安全，并发场景可能导致不致

---

## 如何保证弱一致性、最终一致性
### 缓存延时双删（时长不易确定，且与业务有关）
删缓存； 更新数据库；休眠一会（时长依读频率而定），再次删除缓存

### 删除缓存重试机制（代码侵入，引入队列，增加复杂度）
更新数据库；删除缓存；如果缓存删除失败，将缓存键放入队列；队列重试删除缓存

### 读取binlog异步删除缓存
#### 读请求
程序读缓存，缓存不存在，读数据库

#### 写请求
程序更新数据库，删除缓存；消息队列订阅数据库binlog，异步更新缓存

---

#### 参考
[Redis与MySQL如何保证双写一致](https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247491237&idx=2&sn=2533462d72197e4675828b2e05559cf2&chksm=fc2fa2adcb582bbb0b2fa0837b12c6c8176a2c679f601bec6773eac44da34fb48ba09682bc3b&mpshare=1&scene=1&srcid=0526Q1LADl23wqxVlIPj7z3F&sharer_sharetime=1623288264898&sharer_shareid=8b2f316476844c28a516843cc3902ec6#rd)
